/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./DbStore.ts":
/*!********************!*\
  !*** ./DbStore.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeorm_1 = __webpack_require__(/*! typeorm */ \"typeorm\");\r\nconst ReplyMessage_1 = __webpack_require__(/*! ./models/ReplyMessage */ \"./models/ReplyMessage.ts\");\r\nconst Parameter_1 = __webpack_require__(/*! ./models/Parameter */ \"./models/Parameter.ts\");\r\nconst Facility_1 = __webpack_require__(/*! ./models/Facility */ \"./models/Facility.ts\");\r\nconst Character_1 = __webpack_require__(/*! ./models/Character */ \"./models/Character.ts\");\r\nconst ReplyMessagesController_1 = __webpack_require__(/*! ./controllers/ReplyMessagesController */ \"./controllers/ReplyMessagesController.ts\");\r\nconst FacilitiesController_1 = __webpack_require__(/*! ./controllers/FacilitiesController */ \"./controllers/FacilitiesController.ts\");\r\nconst ParametersController_1 = __webpack_require__(/*! ./controllers/ParametersController */ \"./controllers/ParametersController.ts\");\r\nconst CharactersController_1 = __webpack_require__(/*! ./controllers/CharactersController */ \"./controllers/CharactersController.ts\");\r\nconst MessageConstants_1 = __webpack_require__(/*! ./MessageConstants */ \"./MessageConstants.ts\");\r\nconst Speech_1 = __webpack_require__(/*! ./models/Speech */ \"./models/Speech.ts\");\r\nconst SpeechController_1 = __webpack_require__(/*! ./controllers/SpeechController */ \"./controllers/SpeechController.ts\");\r\n// 設定ファイル\r\nvar config = __webpack_require__(/*! config */ \"config\");\r\nclass DbStore {\r\n    // 接続（シングルトン）\r\n    static createConnection() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._conn) {\r\n                this._conn = yield typeorm_1.createConnection(this.connectionOptions);\r\n            }\r\n            return this._conn;\r\n        });\r\n    }\r\n}\r\n// データベースの設定\r\nDbStore.connectionOptions = {\r\n    // 設定を書くこと\r\n    // 詳しくはここ！\r\n    // https://typeorm.io/\r\n    type: config.database.type,\r\n    database: config.database.database,\r\n    host: config.database.host,\r\n    port: config.database.port,\r\n    username: config.database.username,\r\n    password: config.database.password,\r\n    logging: config.database.logging,\r\n    entities: [\r\n        Character_1.default,\r\n        Facility_1.default,\r\n        Parameter_1.default,\r\n        ReplyMessage_1.default,\r\n        Speech_1.default\r\n    ],\r\n    // Model変更をデータベースのテーブル定義に反映する\r\n    synchronize: config.database.synchronize\r\n};\r\nexports.default = DbStore;\r\n// とりっっちのデータキャッシュ\r\nexports.cache = {};\r\n// 各テーブルをキャッシュする\r\nfunction initialize() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        yield CharactersController_1.default.all().then((val) => { exports.cache[MessageConstants_1.characterTable] = val; });\r\n        yield ParametersController_1.default.all().then((val) => { exports.cache[MessageConstants_1.parameterTable] = val; });\r\n        yield FacilitiesController_1.default.all().then((val) => { exports.cache[MessageConstants_1.facilityTable] = val; });\r\n        yield ReplyMessagesController_1.default.all().then((val) => { exports.cache[MessageConstants_1.replyMessageTable] = val; });\r\n        yield SpeechController_1.default.all().then((val) => { exports.cache[MessageConstants_1.speechTable] = val; });\r\n        console.log(config.messages.cacheEnd);\r\n    });\r\n}\r\nexports.initialize = initialize;\r\n// 各テーブルをDBに一括保存する（削除はしない）\r\nfunction saveAll() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        var connection = yield DbStore.createConnection();\r\n        // 各テーブルの保存\r\n        yield connection.transaction((transactionalEntityManager) => __awaiter(this, void 0, void 0, function* () {\r\n            yield transactionalEntityManager.save(exports.cache[MessageConstants_1.characterTable]);\r\n            yield transactionalEntityManager.save(exports.cache[MessageConstants_1.parameterTable]);\r\n            yield transactionalEntityManager.save(exports.cache[MessageConstants_1.facilityTable]);\r\n            yield transactionalEntityManager.save(exports.cache[MessageConstants_1.replyMessageTable]);\r\n            yield transactionalEntityManager.save(exports.cache[MessageConstants_1.speechTable]);\r\n        }));\r\n    });\r\n}\r\nexports.saveAll = saveAll;\r\n\n\n//# sourceURL=webpack:///./DbStore.ts?");

/***/ }),

/***/ "./DiscordHelper.ts":
/*!**************************!*\
  !*** ./DiscordHelper.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst MessageConstants_1 = __webpack_require__(/*! ./MessageConstants */ \"./MessageConstants.ts\");\r\nconst ToricchiHelper_1 = __webpack_require__(/*! ./ToricchiHelper */ \"./ToricchiHelper.ts\");\r\n/**\r\n * メッセージを受信したときに呼ぶ\r\n * 最後のメッセージを覚える\r\n * @param message 受信メッセージ\r\n */\r\nfunction memoryMessage(message) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // 最後のメッセージを保存\r\n        exports.lastMessage = message;\r\n        // とりっっちの状態更新\r\n        yield ToricchiHelper_1.updateToricchi();\r\n        // ログ表示\r\n        console.log(exports.lastMessage.channel.id + \" : \" + exports.lastMessage.author.username + \" : \" + exports.lastMessage.content);\r\n        return true;\r\n    });\r\n}\r\nexports.memoryMessage = memoryMessage;\r\n/**\r\n * 任意のチャンネルに対してメッセージ送信\r\n * @param client Discordクライアント\r\n * @param channelId チャンネルID\r\n * @param messageStr メッセージ文字列\r\n */\r\nfunction sendMessageToChannel(client, channelId, messageStr) {\r\n    var channel = client.channels.get(channelId);\r\n    channel.send(messageStr);\r\n    return true;\r\n}\r\nexports.sendMessageToChannel = sendMessageToChannel;\r\n/**\r\n * 文字列に\"\\n\"が含まれていたら改行する\r\n * @param messageStr メッセージ文字列\r\n */\r\nfunction modifyNewLineStr(messageStr) {\r\n    var splitted = messageStr.split(\"\\\\n\");\r\n    var result = \"\";\r\n    splitted.forEach(function (currentValue, index, array) {\r\n        if (result) {\r\n            result = result + \"\\n\";\r\n        }\r\n        // currentValue または array[index] について何かする\r\n        result = result + currentValue;\r\n    });\r\n    return result;\r\n}\r\nexports.modifyNewLineStr = modifyNewLineStr;\r\n/**\r\n * 文字列から特定の文字を除外する\r\n * @param messageStr メッセージ文字列\r\n * @returns 除外後の文字列\r\n */\r\nfunction replaceMessage(messageStr) {\r\n    var result = messageStr;\r\n    MessageConstants_1.trimList.forEach((value) => {\r\n        result = result.split(value).join('');\r\n    });\r\n    return result;\r\n}\r\nexports.replaceMessage = replaceMessage;\r\n\n\n//# sourceURL=webpack:///./DiscordHelper.ts?");

/***/ }),

/***/ "./MessageConstants.ts":
/*!*****************************!*\
  !*** ./MessageConstants.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// その他、システム定義\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// テーブル名\r\nexports.characterTable = \"character\";\r\nexports.parameterTable = \"parameter\";\r\nexports.facilityTable = \"facility\";\r\nexports.replyMessageTable = \"replyMessage\";\r\nexports.speechTable = \"speech\";\r\n// メッセージ判定の時に除外する文字リスト\r\nexports.trimList = [' ', '、', ',', '。', '\\n', '　', '・', '･', '.'];\r\n// ヘルプ表示の時に除外する文字リスト\r\nexports.helpTrimList = ['^', '$'];\r\n\n\n//# sourceURL=webpack:///./MessageConstants.ts?");

/***/ }),

/***/ "./Shop.ts":
/*!*****************!*\
  !*** ./Shop.ts ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DbStore_1 = __webpack_require__(/*! ./DbStore */ \"./DbStore.ts\");\r\nconst DiscordHelper_1 = __webpack_require__(/*! ./DiscordHelper */ \"./DiscordHelper.ts\");\r\nconst ToricchiHelper_1 = __webpack_require__(/*! ./ToricchiHelper */ \"./ToricchiHelper.ts\");\r\nconst MessageConstants_1 = __webpack_require__(/*! ./MessageConstants */ \"./MessageConstants.ts\");\r\n// お買い物関係\r\n/**\r\n * 持ち物リスト表示\r\n * @returns テキスト\r\n */\r\nfunction showInventory() {\r\n    var list = DbStore_1.cache[MessageConstants_1.facilityTable].filter(function (value) {\r\n        return (value.level > 0);\r\n    });\r\n    var sb = \"\";\r\n    sb = sb + \"```\";\r\n    if (Object.keys(list).length == 0) {\r\n        sb = sb + ToricchiHelper_1.getSpeech(\"message9\");\r\n    }\r\n    else {\r\n        sb = sb + ToricchiHelper_1.getSpeech(\"message10\");\r\n        list.forEach((value) => {\r\n            sb = sb + `\\n[${value.id}]${value.name}:レベル${value.level} 総合生産量${value.currentIncome}円\\n\\t${value.comment}`;\r\n        });\r\n    }\r\n    sb = sb + \"```\";\r\n    sb = ToricchiHelper_1.correctMessage(sb);\r\n    return sb;\r\n}\r\nexports.showInventory = showInventory;\r\n/**\r\n * 買い物リスト表示\r\n * @param budget 予算\r\n * @returns テキスト\r\n */\r\nfunction showBuyList(budget) {\r\n    var list = DbStore_1.cache[MessageConstants_1.facilityTable].filter(function (value) {\r\n        return (value.currentPrice < budget);\r\n    });\r\n    var sb = \"```\";\r\n    if (Object.keys(list).length == 0) {\r\n        return null;\r\n    }\r\n    else {\r\n        sb = sb + ToricchiHelper_1.getSpeech(\"message10\");\r\n        list.forEach((value) => {\r\n            sb = sb + `\\n[${value.id}]${value.name}:レベル${value.level} 購入価格${value.currentPrice}円 生産力${value.baseIncome}円\\n\\t${value.comment}`;\r\n        });\r\n    }\r\n    sb = sb + \"```\";\r\n    sb = ToricchiHelper_1.correctMessage(sb);\r\n    return sb;\r\n}\r\nexports.showBuyList = showBuyList;\r\n/**\r\n * 買い物成功\r\n */\r\nfunction toricchiItemSuccess() {\r\n    var res = ToricchiHelper_1.getSpeech(\"message11\");\r\n    var character = ToricchiHelper_1.getCharacter(DiscordHelper_1.lastMessage);\r\n    if (character.like >= 5) {\r\n        if (character.like >= 10) {\r\n            res = ToricchiHelper_1.getSpeech(\"message12\");\r\n        }\r\n        else {\r\n            res = ToricchiHelper_1.getSpeech(\"message13\");\r\n        }\r\n    }\r\n    DiscordHelper_1.lastMessage.channel.send(res);\r\n    character.like++;\r\n    return true;\r\n}\r\nexports.toricchiItemSuccess = toricchiItemSuccess;\r\n/**\r\n * 買い物失敗\r\n */\r\nfunction toricchiItemFailure() {\r\n    var res = ToricchiHelper_1.getSpeech(\"message14\");\r\n    var character = ToricchiHelper_1.getCharacter(DiscordHelper_1.lastMessage);\r\n    if (character.like >= 5) {\r\n        if (character.like >= 10) {\r\n            res = ToricchiHelper_1.getSpeech(\"message15\");\r\n        }\r\n        else {\r\n            res = ToricchiHelper_1.getSpeech(\"message16\");\r\n        }\r\n    }\r\n    DiscordHelper_1.lastMessage.channel.send(res);\r\n    character.like--;\r\n    return false;\r\n}\r\nexports.toricchiItemFailure = toricchiItemFailure;\r\n/**\r\n * 収入を計算する\r\n * @returns 収入\r\n */\r\nfunction calculateIncome() {\r\n    var sum = 0;\r\n    DbStore_1.cache[MessageConstants_1.facilityTable].forEach((value) => {\r\n        sum += value.currentIncome;\r\n    });\r\n    return sum;\r\n}\r\n/**\r\n * 買い物中ならば買い物をする\r\n * @returns 買い物判定をしたならばtrue\r\n */\r\nfunction shopping() {\r\n    if (buyWith && buyWith == DiscordHelper_1.lastMessage.author.id) {\r\n        var item = DbStore_1.cache[MessageConstants_1.facilityTable].find((value => DiscordHelper_1.lastMessage.content === String(value.id)));\r\n        if (item) {\r\n            // お買い物\r\n            // お金減少\r\n            ToricchiHelper_1.updateParameter(\"Money\", -item.currentPrice);\r\n            // アイテム状態更新\r\n            item.level++;\r\n            item.currentPrice = Math.floor(item.currentPrice * 1.1);\r\n            item.currentIncome = item.level * item.baseIncome;\r\n            // 収入変更\r\n            var inc = ToricchiHelper_1.getParameter(\"Income\");\r\n            inc.value = String(calculateIncome());\r\n            toricchiItemSuccess();\r\n        }\r\n        else {\r\n            toricchiItemFailure();\r\n        }\r\n        buyWith = null;\r\n        budget = 0;\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nexports.shopping = shopping;\r\n// 一緒にお買い物している人情報\r\nvar buyWith = null;\r\nvar budget = null;\r\n// アイテム購入\r\nfunction buyItemCall() {\r\n    var res = \"\";\r\n    var character = ToricchiHelper_1.getCharacter(DiscordHelper_1.lastMessage);\r\n    budget = ToricchiHelper_1.getParameterNumber(\"Money\");\r\n    if (character.like >= 5) {\r\n        if (character.like < 10) {\r\n            budget = budget * 7 / 10;\r\n        }\r\n    }\r\n    else {\r\n        // 所持金の3割\r\n        budget = budget * 3 / 10;\r\n    }\r\n    // 品物リスト表示\r\n    var buyList = showBuyList(budget);\r\n    if (buyList) {\r\n        res = res + buyList;\r\n        res = res + ToricchiHelper_1.getSpeech(\"message17\");\r\n        // 一緒に買い物中\r\n        buyWith = DiscordHelper_1.lastMessage.author.id;\r\n    }\r\n    else {\r\n        res = res + ToricchiHelper_1.getSpeech(\"message18\");\r\n        buyWith = null;\r\n        budget = 0;\r\n    }\r\n    DiscordHelper_1.lastMessage.channel.send(res);\r\n    return false;\r\n}\r\nexports.buyItemCall = buyItemCall;\r\n// 持ち物表示\r\nfunction inventoryCall() {\r\n    var res = \"\";\r\n    //var character = getCharacter(lastMessage);\r\n    // 持ち物リスト表示\r\n    res = res + showInventory();\r\n    DiscordHelper_1.lastMessage.channel.send(res);\r\n    return true;\r\n}\r\nexports.inventoryCall = inventoryCall;\r\n\n\n//# sourceURL=webpack:///./Shop.ts?");

/***/ }),

/***/ "./ToricchiHelper.ts":
/*!***************************!*\
  !*** ./ToricchiHelper.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Character_1 = __webpack_require__(/*! ./models/Character */ \"./models/Character.ts\");\r\nconst MessageConstants_1 = __webpack_require__(/*! ./MessageConstants */ \"./MessageConstants.ts\");\r\nconst DbStore_1 = __webpack_require__(/*! ./DbStore */ \"./DbStore.ts\");\r\nconst DiscordHelper_1 = __webpack_require__(/*! ./DiscordHelper */ \"./DiscordHelper.ts\");\r\nconst Shop_1 = __webpack_require__(/*! ./Shop */ \"./Shop.ts\");\r\nconst app_1 = __webpack_require__(/*! ./app */ \"./app.ts\");\r\n// 設定ファイル\r\nvar config = __webpack_require__(/*! config */ \"config\");\r\n/**\r\n * 利用者データを取得する\r\n * 無ければ作成する\r\n * @param message メッセージデータ\r\n * @returns 利用者データ\r\n */\r\nfunction getCharacter(message) {\r\n    // 探す\r\n    var result = DbStore_1.cache[MessageConstants_1.characterTable].find(item => item.id === message.author.id);\r\n    if (!result) {\r\n        // 無かったので作成\r\n        console.log(config.messages.makeCharacterMessage + message.author.username);\r\n        result = new Character_1.default();\r\n        result.id = message.author.id;\r\n        result.like = 0;\r\n        result.name = message.author.username;\r\n        DbStore_1.cache[MessageConstants_1.characterTable].push(result);\r\n    }\r\n    return result;\r\n}\r\nexports.getCharacter = getCharacter;\r\n/**\r\n * 利用者データに好感度を加算する\r\n * @param character 利用者データ\r\n * @param like ポイント増分\r\n */\r\nfunction addLike(character, like) {\r\n    // 最小値は-5\r\n    character.like = Math.max(-5, character.like + like);\r\n}\r\nexports.addLike = addLike;\r\n/**\r\n * 好感度を初期値にする\r\n * @param character 利用者データ\r\n */\r\nfunction resetLike(character) {\r\n    character.like = 0;\r\n}\r\nexports.resetLike = resetLike;\r\n/**\r\n * メッセージ受信ごとにとりっっちの状態を更新する\r\n */\r\nfunction updateToricchi() {\r\n    // MP回復\r\n    updateParameterMax(\"Mp\", \"MaxMp\", 1);\r\n    updateParameterMax(\"Stress\", \"MaxStress\", 1);\r\n    // 収入加算\r\n    var income = getParameterNumber(\"Income\");\r\n    updateParameter(\"Money\", income);\r\n    // 戦闘不能ならばHP回復\r\n    var isDead = getParameterNumber(\"IsDead\");\r\n    if (isDead) {\r\n        var temp = updateParameterMax(\"Hp\", \"MaxHp\", 1);\r\n        console.log(\"現在HP:\" + temp.value);\r\n        // 最大値になっていたら復活\r\n        if (Number(temp.value) === getParameterNumber(\"MaxHp\")) {\r\n            console.log(\"復活します\");\r\n            updateParameter(\"IsDead\", -1);\r\n            // 名前変更\r\n            if (getParameter(\"IsToricchi\")) {\r\n                var death = getParameterNumber(\"Death\");\r\n                death = Math.min(50 - config.defaultName.head.length - config.defaultName.foot.length, death);\r\n                var sb = config.defaultName.body;\r\n                for (var i = 0; i < death; i++) {\r\n                    sb = sb + config.defaultName.body;\r\n                }\r\n                app_1.setBotName(config.defaultName.head + sb + config.defaultName.foot);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.updateToricchi = updateToricchi;\r\n/**\r\n * 指定文字数まで文字埋めする\r\n * @param val\r\n * @param char\r\n * @param n\r\n */\r\nfunction paddingright(val, char, n) {\r\n    for (; val.length < n; val += char)\r\n        ;\r\n    return val;\r\n}\r\n/**\r\n * メッセージを修正する\r\n * @param mes 元のメッセージ\r\n * @returns 修正後のメッセージ\r\n */\r\nfunction correctMessage(mes) {\r\n    if (mes) {\r\n        var mes = mes.split(\"\\\\n\").join('\\n'); // \\nで改行させる\r\n        mes = mes.split(\"{name}\").join(DiscordHelper_1.lastMessage.author.username); // {name}に名前を代入する\r\n        mes = mes.split(\"{botname}\").join(getParameter(\"Name\").value); // {botname}に名前を代入する\r\n    }\r\n    return mes;\r\n}\r\nexports.correctMessage = correctMessage;\r\n/**\r\n * 最大値を考慮して加算する\r\n * @param name パラメータ名\r\n * @param maxName 最大値パラメータ名\r\n * @param addValue 加算値\r\n * @returns 処理後のパラメータ\r\n */\r\nfunction updateParameterMax(name, maxName, addValue) {\r\n    if (tempmax) {\r\n        var tempmax = getParameter(maxName);\r\n        var maxValue = Number(tempmax.value);\r\n        return updateParameter(name, addValue, maxValue);\r\n    }\r\n    return tempmax;\r\n}\r\nexports.updateParameterMax = updateParameterMax;\r\n/**\r\n * パラメータを指定してステータスを取得する\r\n * @param name パラメータ名\r\n * @returns 処理後のパラメータ\r\n */\r\nfunction getParameter(name) {\r\n    // 探す\r\n    var result = DbStore_1.cache[MessageConstants_1.parameterTable].find(item => item.name === name);\r\n    return result;\r\n}\r\nexports.getParameter = getParameter;\r\n/**\r\n * パラメータを指定してステータスの数値を取得する\r\n * @param name パラメータ名\r\n * @returns 処理後のパラメータ\r\n */\r\nfunction getParameterNumber(name) {\r\n    var value = getParameter(name);\r\n    return Number(value.value);\r\n}\r\nexports.getParameterNumber = getParameterNumber;\r\n/**\r\n * ステータスを更新する（保存はしない）\r\n * @param name パラメータ名\r\n * @param addValue 加算値\r\n * @param max 最大値、なければ判定なし、0の時は判定されない\r\n * @returns 処理後のパラメータ\r\n */\r\nfunction updateParameter(name, addValue, max = 0) {\r\n    // 取得する\r\n    var tempParameter = getParameter(name);\r\n    // 加える\r\n    if (max) {\r\n        tempParameter.value = (Math.min(max, Number(tempParameter.value) + addValue)).toString();\r\n    }\r\n    else {\r\n        tempParameter.value = (Number(tempParameter.value) + addValue).toString();\r\n    }\r\n    return tempParameter;\r\n}\r\nexports.updateParameter = updateParameter;\r\n/**\r\n * 整数の乱数作成\r\n * @param min この数以上の整数\r\n * @param max この数未満の整数\r\n */\r\nfunction getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}\r\n/**\r\n * 引数で示された名前の関数を呼び出す\r\n * @param functionName 関数名\r\n * @returns 関数の結果\r\n */\r\nfunction evalFunction(functionName) {\r\n    try {\r\n        return eval(functionName + \"()\");\r\n    }\r\n    catch (err) {\r\n        console.log(err);\r\n        return false;\r\n    }\r\n}\r\nexports.evalFunction = evalFunction;\r\n// 各テーブルをDBに一括保存する（削除はしない）\r\nfunction Save() {\r\n    DbStore_1.saveAll();\r\n    return true;\r\n}\r\n// ステータス表示\r\nfunction Status() {\r\n    var character = getCharacter(DiscordHelper_1.lastMessage);\r\n    var level = 1;\r\n    if (character.like >= 10) {\r\n        level = 2;\r\n    }\r\n    var str = \"```\";\r\n    DbStore_1.cache[MessageConstants_1.parameterTable].filter(function (value) {\r\n        return (value.visibleLevel <= level);\r\n    }).forEach((value) => {\r\n        str = str + \"\\n\" + paddingright(value.display, \" \", 10) + \":\" + value.value;\r\n    });\r\n    str = str + \"```\";\r\n    DiscordHelper_1.lastMessage.channel.send(str);\r\n    return true;\r\n}\r\n// 射撃\r\nfunction Shoottori() {\r\n    var res = getSpeech(\"message3\");\r\n    var character = getCharacter(DiscordHelper_1.lastMessage);\r\n    var randomInt = getRandomInt(0, 10) % 2;\r\n    if (character.like >= 10) {\r\n        switch (randomInt) {\r\n            case 0:\r\n                res = getSpeech(\"message6\");\r\n                updateParameter(\"Hp\", -10);\r\n                break;\r\n            default:\r\n                res = getSpeech(\"message7\");\r\n                updateParameter(\"Hp\", -20);\r\n                break;\r\n        }\r\n    }\r\n    else {\r\n        switch (randomInt) {\r\n            case 0:\r\n                res = res + getSpeech(\"message4\");\r\n                break;\r\n            default:\r\n                res = res + getSpeech(\"message5\");\r\n                break;\r\n        }\r\n    }\r\n    // 死亡判定\r\n    if (getParameterNumber(\"Hp\") <= 0) {\r\n        res = res + getSpeech(\"message8\");\r\n        updateParameter(\"IsDead\", 1);\r\n        updateParameter(\"Death\", 1);\r\n        resetLike(character);\r\n    }\r\n    res = correctMessage(res);\r\n    DiscordHelper_1.lastMessage.channel.send(res);\r\n    return true;\r\n}\r\n// コマンド説明\r\nfunction Help() {\r\n    var helpstr = \"```\";\r\n    DbStore_1.cache[MessageConstants_1.replyMessageTable].filter(function (value) {\r\n        return (value.isVisible);\r\n    }).forEach((value) => {\r\n        var result = value.word;\r\n        MessageConstants_1.helpTrimList.forEach((trimchar) => {\r\n            result = result.split(trimchar).join('');\r\n        });\r\n        helpstr = helpstr + \"\\n\" + paddingright(result, \" \", 15) + \"\\t:\" + value.comment;\r\n    });\r\n    helpstr = helpstr + \"\\n```\";\r\n    DiscordHelper_1.lastMessage.channel.send(helpstr);\r\n    return true;\r\n}\r\n// デジタルメガフレア\r\nfunction DigitalMegaFlare() {\r\n    if (getParameterNumber(\"Mp\") >= 100) {\r\n        var income = getParameterNumber(\"Income\") * (getParameterNumber(\"Stress\") + getParameterNumber(\"Hp\"));\r\n        var sb = getSpeech(\"message0\");\r\n        sb = correctMessage(sb);\r\n        sb = sb.split(\"{income}\").join(income.toString());\r\n        DiscordHelper_1.lastMessage.channel.send(sb);\r\n        updateParameter(\"Mp\", -100);\r\n        updateParameter(\"Money\", income);\r\n        return true;\r\n    }\r\n    else {\r\n        DiscordHelper_1.lastMessage.channel.send(getSpeech(\"message1\"));\r\n        return false;\r\n    }\r\n}\r\n// ストレスメッセージ\r\nfunction Stress() {\r\n    if (getParameterNumber(\"Stress\") >= 50) {\r\n        DiscordHelper_1.lastMessage.channel.send(getSpeech(\"message2\"));\r\n        updateParameter(\"Stress\", -50);\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n// 持ち物表示\r\nfunction Inventory() {\r\n    return Shop_1.inventoryCall();\r\n}\r\n// アイテム購入\r\nfunction BuyItem() {\r\n    return Shop_1.buyItemCall();\r\n}\r\nexports.BuyItem = BuyItem;\r\n/**\r\n * 台詞を取得する\r\n * @param speechNo 台詞番号\r\n */\r\nfunction getSpeech(speechNo) {\r\n    var candidateList = [];\r\n    // 条件に合った台詞を集める\r\n    DbStore_1.cache[MessageConstants_1.speechTable].forEach((value) => {\r\n        if (speechNo === value.no) {\r\n            candidateList.push(value);\r\n        }\r\n    });\r\n    // 昇順に並び変える\r\n    candidateList.sort(function (a, b) {\r\n        if (a.dataOrder == null && b.dataOrder == null)\r\n            return 0;\r\n        if (a.dataOrder == null)\r\n            return 1;\r\n        if (b.dataOrder == null)\r\n            return -1;\r\n        if (a.dataOrder > b.dataOrder)\r\n            return 1;\r\n        if (a.dataOrder < b.dataOrder)\r\n            return -1;\r\n        return 0;\r\n    });\r\n    // 改行で繋げる\r\n    var result = \"\";\r\n    candidateList.forEach((value) => {\r\n        result = result + \"\\n\" + value.data;\r\n    });\r\n    // 特殊タグを置き換える\r\n    result = correctMessage(result);\r\n    return result;\r\n}\r\nexports.getSpeech = getSpeech;\r\n\n\n//# sourceURL=webpack:///./ToricchiHelper.ts?");

/***/ }),

/***/ "./app.ts":
/*!****************!*\
  !*** ./app.ts ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst _t = __webpack_require__(/*! typeorm */ \"typeorm\");\r\nconst _r = __webpack_require__(/*! reflect-metadata */ \"reflect-metadata\");\r\nconst DiscordHelper_1 = __webpack_require__(/*! ./DiscordHelper */ \"./DiscordHelper.ts\");\r\nconst MessageConstants_1 = __webpack_require__(/*! ./MessageConstants */ \"./MessageConstants.ts\");\r\nconst ToricchiHelper_1 = __webpack_require__(/*! ./ToricchiHelper */ \"./ToricchiHelper.ts\");\r\nconst DbStore_1 = __webpack_require__(/*! ./DbStore */ \"./DbStore.ts\");\r\nconst Shop_1 = __webpack_require__(/*! ./Shop */ \"./Shop.ts\");\r\nconst Parameter_1 = __webpack_require__(/*! ./models/Parameter */ \"./models/Parameter.ts\");\r\nconst Speech_1 = __webpack_require__(/*! ./models/Speech */ \"./models/Speech.ts\");\r\nconst Facility_1 = __webpack_require__(/*! ./models/Facility */ \"./models/Facility.ts\");\r\nconst ReplyMessage_1 = __webpack_require__(/*! ./models/ReplyMessage */ \"./models/ReplyMessage.ts\");\r\n'use strict';\r\n// 設定ファイル\r\nvar config = __webpack_require__(/*! config */ \"config\");\r\nconst token = config.token;\r\nconst Discord = __webpack_require__(/*! discord.js */ \"discord.js\");\r\nconst client = new Discord.Client();\r\n// ログイン\r\nclient.login(token).then(() => {\r\n    console.log(config.messages.discordConnect);\r\n});\r\n// 初期化処理\r\nclient.on('ready', () => __awaiter(this, void 0, void 0, function* () {\r\n    // データベースのデータをキャッシュする\r\n    console.log(config.messages.cacheMessage);\r\n    yield DbStore_1.initialize();\r\n    // 初期状態チェック\r\n    // 各テーブルを設定ファイルに基づいて初期化する\r\n    if (DbStore_1.cache[MessageConstants_1.parameterTable].length === 0) {\r\n        // パラメータ初期化\r\n        console.log(config.messages.initialzeParameter);\r\n        config.initialParameter.forEach((value) => {\r\n            makeParameter(value.name, value.value, value.visibleLevel, value.display);\r\n        });\r\n        DbStore_1.saveAll();\r\n    }\r\n    if (DbStore_1.cache[MessageConstants_1.facilityTable].length === 0) {\r\n        // 施設データ初期化\r\n        console.log(config.messages.initialzeFacility);\r\n        config.initialFacility.forEach((value) => {\r\n            makeFacility(value.name, value.basePrice, value.baseIncome, value.comment);\r\n        });\r\n        DbStore_1.saveAll();\r\n    }\r\n    if (DbStore_1.cache[MessageConstants_1.replyMessageTable].length === 0) {\r\n        // 会話データ初期化\r\n        console.log(config.messages.initialzeReply);\r\n        config.initialReplyMessage.forEach((value) => {\r\n            makeReplyMessage(value.friendlyPoint, value.word, value.requirePointMin, value.reply, value.func, value.isVisible, ToricchiHelper_1.correctMessage(value.comment));\r\n        });\r\n        DbStore_1.saveAll();\r\n    }\r\n    if (DbStore_1.cache[MessageConstants_1.speechTable].length === 0) {\r\n        // 台詞データ初期化\r\n        console.log(config.messages.initialzeSpeech);\r\n        config.initialSpeech.forEach((value) => {\r\n            makeSpeech(value.no, value.dataOrder, value.data);\r\n        });\r\n        DbStore_1.saveAll();\r\n    }\r\n    // 完了メッセージ\r\n    console.log(config.messages.startupMessage);\r\n}));\r\n// 前回の時刻\r\nvar preHour = 0;\r\n// とりっちのID\r\nvar id = null;\r\n// メッセージの受信\r\nclient.on('message', message => {\r\n    try {\r\n        //Bot自身の発言を無視する\r\n        if (message.author.bot) {\r\n            if (!id) {\r\n                var paramId = ToricchiHelper_1.getParameter(\"BotUserId\");\r\n                var name = ToricchiHelper_1.getParameter(\"Name\");\r\n                if (paramId) {\r\n                    id = paramId.value;\r\n                }\r\n                else {\r\n                    // 初回起動\r\n                    if (name.value === message.author.username) {\r\n                        // BOTのIDを記憶する\r\n                        makeParameter(config.botId.name, message.author.id, config.botId.visibleLevel, config.botId.display);\r\n                        id = message.author.id;\r\n                        // 既定の名前になっている場合、とりっちモードにし、死亡イベントで名前が変更される\r\n                        if (name.value === config.defaultName.head + config.defaultName.body + config.defaultName.foot) {\r\n                            makeParameter(config.toricchiMode.name, config.toricchiMode.value, config.toricchiMode.visibleLevel, config.toricchiMode.display);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        // 最後のメッセージを保持、表示\r\n        DiscordHelper_1.memoryMessage(message);\r\n        // 死んでたら更新処理のみ\r\n        var isDead = ToricchiHelper_1.getParameterNumber(\"IsDead\");\r\n        if (!isDead) {\r\n            // メッセージから特定の文字を除外する\r\n            var tempMessage = DiscordHelper_1.replaceMessage(message.content);\r\n            if (!Shop_1.shopping()) {\r\n                // 買い物ではない場合\r\n                if (tempMessage.length > 0) {\r\n                    // 条件に合ったメッセージを取得\r\n                    var candidateList = getCandidateList(tempMessage);\r\n                    // 候補がある場合\r\n                    if (candidateList.length > 0) {\r\n                        // 発言者データ取得関数\r\n                        var character = ToricchiHelper_1.getCharacter(message);\r\n                        // ポイントの高い物から使用するメッセージを判定\r\n                        var messageData = candidateList.find(function (value) {\r\n                            return !value.requirePointMin || value.requirePointMin <= character.like;\r\n                        });\r\n                        // 単純なメッセージ返信\r\n                        if (messageData.reply) {\r\n                            var mes = ToricchiHelper_1.correctMessage(messageData.reply);\r\n                            message.channel.send(mes);\r\n                        }\r\n                        // 関数の動的呼び出し\r\n                        var success = true;\r\n                        if (messageData.function) {\r\n                            success = ToricchiHelper_1.evalFunction(messageData.function);\r\n                        }\r\n                        // 全て成功したら発言者に好感度加算\r\n                        if (success) {\r\n                            if (messageData.friendlyPoint) {\r\n                                ToricchiHelper_1.addLike(character, messageData.friendlyPoint);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // 不要な文字を除外した結果何もなくなった場合はランダムで返答する\r\n                    // 画像だけの場合もあるので\r\n                    if (!message.attachments.size || message.attachments.size === 0) {\r\n                        message.channel.send(randomMessage(config.nothingMessage));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // 1時間ごとに保存\r\n        var now = new Date();\r\n        var hour = now.getHours();\r\n        if (hour !== preHour) {\r\n            preHour = hour;\r\n            DbStore_1.saveAll();\r\n            console.log(config.messages.saveEnd);\r\n        }\r\n    }\r\n    catch (error) {\r\n        showError(error);\r\n    }\r\n});\r\n// discordクライアントにエラーが発生した場合\r\n// 一旦強制的に切断して、再接続を試みます。\r\nvar reconnecting = 0; // 接続中\r\nclient.on('error', (error) => __awaiter(this, void 0, void 0, function* () {\r\n    if (reconnecting == 0) {\r\n        reconnecting = 1; // 切断中\r\n        showError(error);\r\n        // 強制切断\r\n        console.log(config.messages.destroy);\r\n        client.destroy().then((value) => __awaiter(this, void 0, void 0, function* () {\r\n            console.log(config.messages.destroyEnd);\r\n            yield reconnect(10);\r\n        }));\r\n    }\r\n}));\r\n/**\r\n * 繋がるまで再接続を試みます\r\n * @param seconds 待ち時間（秒）\r\n */\r\nfunction reconnect(seconds) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        while (reconnecting == 1) {\r\n            // 数秒待つ\r\n            console.log(seconds + config.messages.reconnectWait);\r\n            yield sleep(seconds * 1000);\r\n            // 再接続\r\n            console.log(config.messages.reconnect);\r\n            yield client.login(token).then(() => {\r\n                // 何故かここに来ない。ライブラリの不具合？\r\n                console.log(config.messages.reconnectEnd);\r\n                reconnecting = 0;\r\n            }).catch((error) => {\r\n                showError(error);\r\n            });\r\n        }\r\n    });\r\n}\r\n/**\r\n * メッセージ候補を降順で取得する\r\n * @param messageContent メッセージ本文\r\n * @returns メッセージ候補リスト（ポイント降順）\r\n */\r\nfunction getCandidateList(messageContent) {\r\n    var candidateList = [];\r\n    // メッセージ一覧を取得\r\n    // 条件に合ったメッセージを集める\r\n    DbStore_1.cache[MessageConstants_1.replyMessageTable].forEach((value) => {\r\n        if (messageContent.match(new RegExp(value.word, 'g'))) {\r\n            candidateList.push(value);\r\n        }\r\n    });\r\n    // 降順に並び変える\r\n    candidateList.sort(function (a, b) {\r\n        if (a.requirePointMin == null && b.requirePointMin == null)\r\n            return 0;\r\n        if (a.requirePointMin == null)\r\n            return 1;\r\n        if (b.requirePointMin == null)\r\n            return -1;\r\n        if (a.requirePointMin < b.requirePointMin)\r\n            return 1;\r\n        if (a.requirePointMin > b.requirePointMin)\r\n            return -1;\r\n        return 0;\r\n    });\r\n    return candidateList;\r\n}\r\n/**\r\n * とりっちの名前変更\r\n * @param newname\r\n */\r\nfunction setBotName(newname) {\r\n    console.log(config.messages.changeName + newname);\r\n    if (id) {\r\n        client.fetchUser(id).then((value) => {\r\n            value.setUsername(newname);\r\n            var name = ToricchiHelper_1.getParameter(\"Name\");\r\n            name.value = newname;\r\n            value.lastMessage.member.setNickname(newname).catch((error) => {\r\n                showError(error);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.setBotName = setBotName;\r\n// パラメータを追加する\r\nfunction makeParameter(name, value, visibleLevel, display) {\r\n    var temp = new Parameter_1.default();\r\n    temp.value = value;\r\n    temp.name = name;\r\n    temp.visibleLevel = visibleLevel;\r\n    temp.display = display;\r\n    DbStore_1.cache[MessageConstants_1.parameterTable].push(temp);\r\n}\r\n// 施設を追加する\r\nfunction makeFacility(name, basePrice, baseIncome, comment) {\r\n    var temp = new Facility_1.default();\r\n    temp.name = name;\r\n    temp.basePrice = basePrice;\r\n    temp.baseIncome = baseIncome;\r\n    temp.level = 0;\r\n    temp.currentPrice = basePrice;\r\n    temp.currentIncome = baseIncome;\r\n    temp.comment = comment;\r\n    DbStore_1.cache[MessageConstants_1.parameterTable].push(temp);\r\n}\r\n// 応答メッセージを追加する\r\nfunction makeReplyMessage(friendlyPoint, word, requirePointMin, reply, func, isVisible, comment) {\r\n    var temp = new ReplyMessage_1.default();\r\n    if (friendlyPoint) {\r\n        temp.friendlyPoint = friendlyPoint;\r\n    }\r\n    temp.word = word;\r\n    if (requirePointMin) {\r\n        temp.requirePointMin = requirePointMin;\r\n    }\r\n    temp.reply = reply;\r\n    if (func) {\r\n        temp.function = func;\r\n    }\r\n    temp.isVisible = isVisible;\r\n    if (comment) {\r\n        temp.comment = comment;\r\n    }\r\n    DbStore_1.cache[MessageConstants_1.parameterTable].push(temp);\r\n}\r\n// 台詞を追加する\r\nfunction makeSpeech(no, dataOrder, data) {\r\n    var temp = new Speech_1.default();\r\n    temp.no = no;\r\n    temp.dataOrder = dataOrder;\r\n    temp.data = data;\r\n    DbStore_1.cache[MessageConstants_1.parameterTable].push(temp);\r\n}\r\n/**\r\n * 待機する\r\n * @param milliseconds ミリ秒\r\n */\r\nfunction sleep(milliseconds) {\r\n    return new Promise(resolve => {\r\n        setTimeout(() => resolve(), milliseconds);\r\n    });\r\n}\r\n/**\r\n * エラー内容表示\r\n * @param error\r\n */\r\nfunction showError(error) {\r\n    console.log(config.messages.reconnectFailed + error.name);\r\n    console.log(error.message);\r\n    console.log(error.stack);\r\n}\r\n/**\r\n * ランダムで選択するメッセージ\r\n * @param values\r\n */\r\nfunction randomMessage(values) {\r\n    return values[Math.floor(Math.random() * values.length)];\r\n}\r\n\n\n//# sourceURL=webpack:///./app.ts?");

/***/ }),

/***/ "./controllers/CharactersController.ts":
/*!*********************************************!*\
  !*** ./controllers/CharactersController.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Character_1 = __webpack_require__(/*! ../models/Character */ \"./models/Character.ts\");\r\nconst DbStore_1 = __webpack_require__(/*! ../DbStore */ \"./DbStore.ts\");\r\nclass CharacterController {\r\n    // GET /character\r\n    // 全件取得（offset, limitをパラメータに受け取ることも可能）\r\n    static all() {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Character_1.default);\r\n                // 存在チェック\r\n                const allData = yield repository.find();\r\n                resolve(allData);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // GET /character/{id}\r\n    // 指定したIDのタスクを取得する\r\n    static get(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Character_1.default);\r\n                // 存在チェック\r\n                const result = yield repository.findOne(id);\r\n                if (!result) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                resolve(result);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // POST /character\r\n    // タスクを登録する\r\n    static add(param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Character_1.default);\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // PUT /character/{id}\r\n    // 指定したIDのタスクを更新する\r\n    static update(id, param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Character_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(data.id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 更新\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // DELETE /character/{id}\r\n    // 指定したIDのタスクを削除する\r\n    static delete(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Character_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 削除\r\n                result = yield repository.remove(exist);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n}\r\nexports.default = CharacterController;\r\n\n\n//# sourceURL=webpack:///./controllers/CharactersController.ts?");

/***/ }),

/***/ "./controllers/FacilitiesController.ts":
/*!*********************************************!*\
  !*** ./controllers/FacilitiesController.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Facility_1 = __webpack_require__(/*! ../models/Facility */ \"./models/Facility.ts\");\r\nconst DbStore_1 = __webpack_require__(/*! ../DbStore */ \"./DbStore.ts\");\r\nclass FacilityController {\r\n    // GET /facility\r\n    // 全件取得（offset, limitをパラメータに受け取ることも可能）\r\n    static all() {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Facility_1.default);\r\n                // 存在チェック\r\n                const allData = yield repository.find();\r\n                resolve(allData);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // GET /facility/{id}\r\n    // 指定したIDのタスクを取得する\r\n    static get(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Facility_1.default);\r\n                // 存在チェック\r\n                const result = yield repository.findOne(id);\r\n                if (!result) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                resolve(result);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // POST /facility\r\n    // タスクを登録する\r\n    static add(param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Facility_1.default);\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // PUT /facility/{id}\r\n    // 指定したIDのタスクを更新する\r\n    static update(id, param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Facility_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(data.id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 更新\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // DELETE /facility/{id}\r\n    // 指定したIDのタスクを削除する\r\n    static delete(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Facility_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 削除\r\n                result = yield repository.remove(exist);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n}\r\nexports.default = FacilityController;\r\n\n\n//# sourceURL=webpack:///./controllers/FacilitiesController.ts?");

/***/ }),

/***/ "./controllers/ParametersController.ts":
/*!*********************************************!*\
  !*** ./controllers/ParametersController.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Parameter_1 = __webpack_require__(/*! ../models/Parameter */ \"./models/Parameter.ts\");\r\nconst DbStore_1 = __webpack_require__(/*! ../DbStore */ \"./DbStore.ts\");\r\nclass ParameterController {\r\n    // GET /parameter\r\n    // 全件取得（offset, limitをパラメータに受け取ることも可能）\r\n    static all() {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Parameter_1.default);\r\n                // 存在チェック\r\n                const allData = yield repository.find();\r\n                resolve(allData);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // GET /parameter/{id}\r\n    // 指定したIDのタスクを取得する\r\n    static get(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Parameter_1.default);\r\n                // 存在チェック\r\n                const result = yield repository.findOne(id);\r\n                if (!result) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                resolve(result);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // POST /parameter\r\n    // タスクを登録する\r\n    static add(param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Parameter_1.default);\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // PUT /parameter/{id}\r\n    // 指定したIDのタスクを更新する\r\n    static update(id, param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Parameter_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(data.id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 更新\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // DELETE /parameter/{id}\r\n    // 指定したIDのタスクを削除する\r\n    static delete(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Parameter_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 削除\r\n                result = yield repository.remove(exist);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n}\r\nexports.default = ParameterController;\r\n\n\n//# sourceURL=webpack:///./controllers/ParametersController.ts?");

/***/ }),

/***/ "./controllers/ReplyMessagesController.ts":
/*!************************************************!*\
  !*** ./controllers/ReplyMessagesController.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ReplyMessage_1 = __webpack_require__(/*! ../models/ReplyMessage */ \"./models/ReplyMessage.ts\");\r\nconst DbStore_1 = __webpack_require__(/*! ../DbStore */ \"./DbStore.ts\");\r\nclass ReplyMessageController {\r\n    // GET /replyMessage\r\n    // 全件取得（offset, limitをパラメータに受け取ることも可能）\r\n    static all() {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(ReplyMessage_1.default);\r\n                // 存在チェック\r\n                const allData = yield repository.find();\r\n                resolve(allData);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // GET /replyMessage/{id}\r\n    // 指定したIDのタスクを取得する\r\n    static get(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(ReplyMessage_1.default);\r\n                // 存在チェック\r\n                const result = yield repository.findOne(id);\r\n                if (!result) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                resolve(result);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // POST /replyMessage\r\n    // タスクを登録する\r\n    static add(param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(ReplyMessage_1.default);\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // PUT /replyMessage/{id}\r\n    // 指定したIDのタスクを更新する\r\n    static update(id, param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(ReplyMessage_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(data.id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 更新\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // DELETE /replyMessage/{id}\r\n    // 指定したIDのタスクを削除する\r\n    static delete(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(ReplyMessage_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 削除\r\n                result = yield repository.remove(exist);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n}\r\nexports.default = ReplyMessageController;\r\n\n\n//# sourceURL=webpack:///./controllers/ReplyMessagesController.ts?");

/***/ }),

/***/ "./controllers/SpeechController.ts":
/*!*****************************************!*\
  !*** ./controllers/SpeechController.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Speech_1 = __webpack_require__(/*! ../models/Speech */ \"./models/Speech.ts\");\r\nconst DbStore_1 = __webpack_require__(/*! ../DbStore */ \"./DbStore.ts\");\r\nclass SpeechController {\r\n    // GET /Speech\r\n    // 全件取得（offset, limitをパラメータに受け取ることも可能）\r\n    static all() {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Speech_1.default);\r\n                // 存在チェック\r\n                const allData = yield repository.find();\r\n                resolve(allData);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // GET /Speech/{id}\r\n    // 指定したIDのタスクを取得する\r\n    static get(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Speech_1.default);\r\n                // 存在チェック\r\n                const result = yield repository.findOne(id);\r\n                if (!result) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                resolve(result);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        }));\r\n    }\r\n    // POST /Speech\r\n    // タスクを登録する\r\n    static add(param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Speech_1.default);\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // PUT /Speech/{id}\r\n    // 指定したIDのタスクを更新する\r\n    static update(id, param) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let data = param;\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Speech_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(data.id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 更新\r\n                result = yield repository.save(data);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n    // DELETE /Speech/{id}\r\n    // 指定したIDのタスクを削除する\r\n    static delete(id) {\r\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            try {\r\n                const connection = yield DbStore_1.default.createConnection();\r\n                let repository = connection.getRepository(Speech_1.default);\r\n                // 存在チェック\r\n                const exist = yield repository.findOne(id);\r\n                if (!exist) {\r\n                    reject({\r\n                        code: 404,\r\n                        message: '指定IDが見つかりませんでした'\r\n                    });\r\n                }\r\n                // 削除\r\n                result = yield repository.remove(exist);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(result);\r\n        }));\r\n    }\r\n}\r\nexports.default = SpeechController;\r\n\n\n//# sourceURL=webpack:///./controllers/SpeechController.ts?");

/***/ }),

/***/ "./models/Character.ts":
/*!*****************************!*\
  !*** ./models/Character.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeorm_1 = __webpack_require__(/*! typeorm */ \"typeorm\");\r\n// Charactersテーブル\r\n// 使用者の情報保存\r\nlet Character = class Character {\r\n};\r\n__decorate([\r\n    typeorm_1.Column({\r\n        primary: true,\r\n        type: 'varchar',\r\n        comment: 'DiscordID',\r\n        length: 20,\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Character.prototype, \"id\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Name',\r\n        type: 'varchar',\r\n        comment: '名前',\r\n        length: 50,\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Character.prototype, \"name\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Like',\r\n        type: 'int',\r\n        comment: '好感度',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Character.prototype, \"like\", void 0);\r\n__decorate([\r\n    typeorm_1.CreateDateColumn({\r\n        name: 'CreatedAt',\r\n        comment: '作成日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Character.prototype, \"createdAt\", void 0);\r\n__decorate([\r\n    typeorm_1.UpdateDateColumn({\r\n        name: 'UpdatedAt',\r\n        comment: '更新日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Character.prototype, \"updatedAt\", void 0);\r\nCharacter = __decorate([\r\n    typeorm_1.Entity(\"Characters\")\r\n], Character);\r\nexports.default = Character;\r\n\n\n//# sourceURL=webpack:///./models/Character.ts?");

/***/ }),

/***/ "./models/Facility.ts":
/*!****************************!*\
  !*** ./models/Facility.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeorm_1 = __webpack_require__(/*! typeorm */ \"typeorm\");\r\n// Facilitiesテーブル\r\n// 購入する施設\r\nlet Facility = class Facility {\r\n};\r\n__decorate([\r\n    typeorm_1.PrimaryGeneratedColumn({\r\n        type: 'int',\r\n        comment: '通し番号'\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Facility.prototype, \"id\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Name',\r\n        type: 'varchar',\r\n        comment: '名前',\r\n        length: 50,\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Facility.prototype, \"name\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'BasePrice',\r\n        type: 'int',\r\n        comment: '基本価格',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Facility.prototype, \"basePrice\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'BaseIncome',\r\n        type: 'int',\r\n        comment: '基本利益',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Facility.prototype, \"baseIncome\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Level',\r\n        type: 'int',\r\n        comment: 'レベル',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Facility.prototype, \"level\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'CurrentPrice',\r\n        type: 'int',\r\n        comment: '現在価格',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Facility.prototype, \"currentPrice\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'CurrentIncome',\r\n        type: 'int',\r\n        comment: '現在の生産量',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Facility.prototype, \"currentIncome\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Comment',\r\n        type: 'varchar',\r\n        comment: '説明',\r\n        length: 100,\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Facility.prototype, \"comment\", void 0);\r\n__decorate([\r\n    typeorm_1.CreateDateColumn({\r\n        name: 'CreatedAt',\r\n        comment: '作成日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Facility.prototype, \"createdAt\", void 0);\r\n__decorate([\r\n    typeorm_1.UpdateDateColumn({\r\n        name: 'UpdatedAt',\r\n        comment: '更新日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Facility.prototype, \"updatedAt\", void 0);\r\nFacility = __decorate([\r\n    typeorm_1.Entity(\"Facilities\")\r\n], Facility);\r\nexports.default = Facility;\r\n\n\n//# sourceURL=webpack:///./models/Facility.ts?");

/***/ }),

/***/ "./models/Parameter.ts":
/*!*****************************!*\
  !*** ./models/Parameter.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeorm_1 = __webpack_require__(/*! typeorm */ \"typeorm\");\r\n// Parametersテーブル\r\n// パラメータ\r\nlet Parameter = class Parameter {\r\n};\r\n__decorate([\r\n    typeorm_1.PrimaryGeneratedColumn({\r\n        type: 'int',\r\n        comment: '通し番号'\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Parameter.prototype, \"id\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Name',\r\n        type: 'varchar',\r\n        comment: '名前',\r\n        length: 50,\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Parameter.prototype, \"name\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Value',\r\n        type: 'varchar',\r\n        comment: '値',\r\n        length: 50,\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Parameter.prototype, \"value\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'VisibleLevel',\r\n        type: 'int',\r\n        comment: '好感度による表示',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Parameter.prototype, \"visibleLevel\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Display',\r\n        type: 'varchar',\r\n        comment: '表示するパラメータ名',\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Parameter.prototype, \"display\", void 0);\r\n__decorate([\r\n    typeorm_1.CreateDateColumn({\r\n        name: 'CreatedAt',\r\n        comment: '作成日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Parameter.prototype, \"createdAt\", void 0);\r\n__decorate([\r\n    typeorm_1.UpdateDateColumn({\r\n        name: 'UpdatedAt',\r\n        comment: '更新日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Parameter.prototype, \"updatedAt\", void 0);\r\nParameter = __decorate([\r\n    typeorm_1.Entity(\"Parameters\")\r\n], Parameter);\r\nexports.default = Parameter;\r\n\n\n//# sourceURL=webpack:///./models/Parameter.ts?");

/***/ }),

/***/ "./models/ReplyMessage.ts":
/*!********************************!*\
  !*** ./models/ReplyMessage.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeorm_1 = __webpack_require__(/*! typeorm */ \"typeorm\");\r\n// ReplyMessagesテーブル\r\n// 応答メッセージ\r\nlet ReplyMessage = class ReplyMessage {\r\n};\r\n__decorate([\r\n    typeorm_1.PrimaryGeneratedColumn({\r\n        type: 'int',\r\n        comment: '通し番号'\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], ReplyMessage.prototype, \"id\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'FriendlyPoint',\r\n        type: 'int',\r\n        comment: '好感度増減値',\r\n        nullable: true\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], ReplyMessage.prototype, \"friendlyPoint\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Word',\r\n        type: 'varchar',\r\n        comment: '応答キーワード',\r\n        length: 100,\r\n        nullable: true\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], ReplyMessage.prototype, \"word\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'RequirePointMin',\r\n        type: 'int',\r\n        comment: '応答好感度最小値',\r\n        nullable: true\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], ReplyMessage.prototype, \"requirePointMin\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Reply',\r\n        type: 'varchar',\r\n        comment: '応答内容',\r\n        length: 200,\r\n        nullable: true\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], ReplyMessage.prototype, \"reply\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Function',\r\n        type: 'varchar',\r\n        comment: '呼び出す関数名',\r\n        nullable: true\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], ReplyMessage.prototype, \"function\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'IsVisible',\r\n        type: 'boolean',\r\n        comment: '説明表示するか',\r\n        default: true\r\n    }),\r\n    __metadata(\"design:type\", Boolean)\r\n], ReplyMessage.prototype, \"isVisible\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'Comment',\r\n        type: 'varchar',\r\n        comment: '説明',\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], ReplyMessage.prototype, \"comment\", void 0);\r\n__decorate([\r\n    typeorm_1.CreateDateColumn({\r\n        name: 'CreatedAt',\r\n        comment: '作成日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], ReplyMessage.prototype, \"createdAt\", void 0);\r\n__decorate([\r\n    typeorm_1.UpdateDateColumn({\r\n        name: 'UpdatedAt',\r\n        comment: '更新日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], ReplyMessage.prototype, \"updatedAt\", void 0);\r\nReplyMessage = __decorate([\r\n    typeorm_1.Entity(\"ReplyMessages\")\r\n], ReplyMessage);\r\nexports.default = ReplyMessage;\r\n\n\n//# sourceURL=webpack:///./models/ReplyMessage.ts?");

/***/ }),

/***/ "./models/Speech.ts":
/*!**************************!*\
  !*** ./models/Speech.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeorm_1 = __webpack_require__(/*! typeorm */ \"typeorm\");\r\n// Speechテーブル\r\n// BOTの台詞やメッセージの格納\r\nlet Speech = class Speech {\r\n};\r\n__decorate([\r\n    typeorm_1.PrimaryGeneratedColumn({\r\n        type: 'int',\r\n        comment: '通し番号'\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Speech.prototype, \"id\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'no',\r\n        type: 'varchar',\r\n        comment: '台詞番号：複数行の台詞は同じ番号を指定する',\r\n        length: 10,\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Speech.prototype, \"no\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'dataOrder',\r\n        type: 'int',\r\n        comment: '台詞番号が同じメッセージの並び順',\r\n        default: 0\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Speech.prototype, \"dataOrder\", void 0);\r\n__decorate([\r\n    typeorm_1.Column({\r\n        name: 'data',\r\n        type: 'varchar',\r\n        comment: '台詞',\r\n        length: 255,\r\n        default: '何か設定しなさい'\r\n    }),\r\n    __metadata(\"design:type\", String)\r\n], Speech.prototype, \"data\", void 0);\r\n__decorate([\r\n    typeorm_1.CreateDateColumn({\r\n        name: 'CreatedAt',\r\n        comment: '作成日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Speech.prototype, \"createdAt\", void 0);\r\n__decorate([\r\n    typeorm_1.UpdateDateColumn({\r\n        name: 'UpdatedAt',\r\n        comment: '更新日'\r\n    }),\r\n    __metadata(\"design:type\", Date)\r\n], Speech.prototype, \"updatedAt\", void 0);\r\nSpeech = __decorate([\r\n    typeorm_1.Entity(\"Speechs\")\r\n], Speech);\r\nexports.default = Speech;\r\n\n\n//# sourceURL=webpack:///./models/Speech.ts?");

/***/ }),

/***/ "config":
/*!*************************!*\
  !*** external "config" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"config\");\n\n//# sourceURL=webpack:///external_%22config%22?");

/***/ }),

/***/ "discord.js":
/*!*****************************!*\
  !*** external "discord.js" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"discord.js\");\n\n//# sourceURL=webpack:///external_%22discord.js%22?");

/***/ }),

/***/ "reflect-metadata":
/*!***********************************!*\
  !*** external "reflect-metadata" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"reflect-metadata\");\n\n//# sourceURL=webpack:///external_%22reflect-metadata%22?");

/***/ }),

/***/ "typeorm":
/*!**************************!*\
  !*** external "typeorm" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"typeorm\");\n\n//# sourceURL=webpack:///external_%22typeorm%22?");

/***/ })

/******/ });